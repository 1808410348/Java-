可重入锁又名递归锁。是指在同一个线程在外层获取锁的时候，再进入该线程的内层方法会自动获取锁（前提，锁对象得是同一个对象）。不会因为之前已经获取过还没有释放而阻塞。

**Java中 ReentrantLock 和 synchronized 都是可重入锁**，可重入锁的一个优点是可一定程度避免死锁。



“可重入锁”四字解释

- 可：可以
- 重：再次
- 入：进入
- 锁：同步锁
- 进入什么：进入同步域（即同步代码块/方法或显示锁锁定的代码）
- 一句话：一个线程中的多个流程可以获取同一把锁，持有这把同步锁可以再次进入。自己可以获取自己的内部锁。

#### 可重入锁种类

1. 隐式锁（即 synchronized关键字使用的锁）默认是可重入锁
     同步块

   ```java
   package com.romanticLei;
   
   /**
    * @author Romantic-Lei
    * @version 1.0
    * @date 2020/11/11
    */
   public class ReEnterLockDemo {
   
       static Object objectLockA = new Object();
   
       // 同步代码块
       public static void m1(){
           new Thread(() -> {
               synchronized (objectLockA){
                   System.out.println(Thread.currentThread().getName()+"\t"+"-----------外层调用");
                   synchronized (objectLockA){
                       System.out.println(Thread.currentThread().getName()+"\t"+"-----------中层调用");
                       synchronized (objectLockA){
                           System.out.println(Thread.currentThread().getName()+"\t"+"-----------内层调用");
                       }
                   }
               }
           }, "t1").start();
       }
   
       public static void main(String[] args) {
           m1();
       }
   }
   t1	-----------外层调用
   t1	-----------中层调用
   t1	-----------内层调用
   ```

     同步方法

   ```java 
   package com.romanticLei;
   
   /**
    * @author Romantic-Lei
    * @version 1.0
    * @date 2020/11/11
    */
   public class ReEnterLockDemo {
   
       static Object objectLockA = new Object();
   
       // 同步方法
       public synchronized void m2(){
           System.out.println("=====外");
           m3();
       }
   
       public synchronized void m3(){
           System.out.println("=====中");
           m5();
       }
   
       public synchronized void m5(){
           System.out.println("=====内");
       }
   
   
       public static void main(String[] args) {
           new ReEnterLockDemo().m2();
       }
   }
   =====外
   =====中
   =====内
   ```

2. Synchronized 的重入的实现机理

   ```
   每个锁对象拥有一个锁计数器和一个指向持有该锁的线程的指针。
   
   当执行monitorenter 时，如果目标锁对象的计数器为零，那么说明它没有被其他线程所持有，Java虚拟机会将该锁对象的持有线程设置为当前线程，并且将其计数器加1。
   
   在目标锁对象的计数器不为零的情况下，如果锁对象的持有线程是当前线程，那么 Java虚拟机可以将其计数器加1，否则需要等待，直到持有线程释放该锁。
   
   当执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零表示锁已被释放。
   ```

   

3. 显示锁（即Lock）也有ReentrantLock 这样的可重入锁。

```java 
public void sycMethod(){
        lock.lock();
//        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "----外层调用lock");
            lock.lock();
            try {
                System.out.println("----内层调用lock");
            } finally {
                lock.unlock();
            }
        } finally {
            lock.unlock();
            // 有lock加锁就需要有相应的解锁，不然会造成死锁
            // 如果解锁次数多于加锁次数 会出现异常java.lang.IllegalMonitorStateException
            // 此处故意让加锁次数和解锁次数不一致，让后面线程等待
            // lock.unlock();
        }
    }
```

