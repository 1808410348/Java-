## 从ReentrantLock开始解读AQS

Lock接口的实现类，基本都是通过【聚合】了一个【队列同步器】的子类完成线程访问控制的

#### ReentrantLock的原理

![ReentrantLock原理图](images/ReentrantLock原理图.jpg)

#### 从最简单的lock方法开始看看公平和非公平

![公平锁方法与非公平锁方法](images/公平锁方法与非公平锁方法.png)![ReentrantLock构造方法](images/ReentrantLock构造方法.jpg)

![lock方法看公平与非公平锁](images/lock方法看公平与非公平锁.jpg)

**可以明显看出公平锁和非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuePredecessors()，hasQueuePredecessors是公平锁加锁时判断等待队列中是否存在有效结点的方法。**



#### 非公平锁走起，方法lock()

对比公平锁和非公平锁tryAcquire()方法的实现代码，其实差别就在于非公平锁获取锁时比公平锁少了一个判断!hasQueuedPredecessors()。

hasQueuedPredecessors()中判断了是否需要排队，导致了公平锁和非公平锁的差异如下：

**公平锁：**公平锁讲究先到先得，线程在获取锁时，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入到等待队列中；

**非公平锁：**不管是否有等待队列，如果可以获取锁，则立即占有锁对象，也就是说队列的第一个线程在unpark()，之后还是需要竞争锁（存在线程竞争的情况下）

![ReentrantLock公平锁与非公平锁](images/ReentrantLock公平锁与非公平锁.jpg)

![ReentrantLock调用acquire方法](images/ReentrantLock调用acquire方法.jpg)

##### AQS源码深度分析

lock()方法

![lock方法](images/lock方法.jpg)

acquire()







