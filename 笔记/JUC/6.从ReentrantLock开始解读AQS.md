## 从ReentrantLock开始解读AQS

Lock接口的实现类，基本都是通过【聚合】了一个【队列同步器】的子类完成线程访问控制的

#### ReentrantLock的原理

![ReentrantLock原理图](images/ReentrantLock原理图.jpg)

#### 从最简单的lock方法开始看看公平和非公平

![公平锁方法与非公平锁方法](images/公平锁方法与非公平锁方法.png)![ReentrantLock构造方法](images/ReentrantLock构造方法.jpg)

![lock方法看公平与非公平锁](images/lock方法看公平与非公平锁.jpg)

**可以明显看出公平锁和非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuePredecessors()，hasQueuePredecessors是公平锁加锁时判断等待队列中是否存在有效结点的方法。**



#### 非公平锁走起，方法lock()

对比公平锁和非公平锁tryAcquire()方法的实现代码，其实差别就在于非公平锁获取锁时比公平锁少了一个判断!hasQueuedPredecessors()。

hasQueuedPredecessors()中判断了是否需要排队，导致了公平锁和非公平锁的差异如下：

**公平锁：**公平锁讲究先到先得，线程在获取锁时，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入到等待队列中；

**非公平锁：**不管是否有等待队列，如果可以获取锁，则立即占有锁对象，也就是说队列的第一个线程在unpark()，之后还是需要竞争锁（存在线程竞争的情况下）

![ReentrantLock公平锁与非公平锁](images/ReentrantLock公平锁与非公平锁.jpg)

![ReentrantLock调用acquire方法](images/ReentrantLock调用acquire方法.jpg)

##### AQS源码深度分析

**lock()方法**

![lock方法](images/lock方法.jpg)

代码解读

```
在第一个线程进来加锁的时候，由于Node结点默认的状态是0，所以第一个线程会走if判断，通过底层CAS改变自身状态码为1，将当前线程设置为自己。当第二个线程进来的时候，获取到的状态state为1，if条件自旋不成立，进入else条件，调用acquire()方法。
```

**acquire()方法**

源码和3大流程走向

![AQS之源码解析](images/AQS之源码解析.jpg)

**tryAcquire(arg)方法**

演示非公平锁

![演示非公平锁](images/演示非公平锁.png)

![nonfairTryAcquire(acquires).](images/nonfairTryAcquire(acquires).jpg)

代码解读

```
第二个线程进来后，首先执行绿框代码，发现当前执行的线程状态为1，红框代码不成立；current获取的是当前进来执行的线程，也就是第二个线程，getExclusiveOwnerThread()方法获取到的是正在受理的线程，也就是第一个线程，他们不相等，所以也不成立；最后直接返回一个false。
那么红框代码是什么意思呢？就是当第二个线程进来的时候，第一个线程刚好处理完，并且把状态state修改为0，那么第二个线程刚好可以抢占线程，并且把自己设置为正在受理的线程，返回true，外层方法结束，类似于双端检测机制。
蓝框代码什么意思呢？就是第一个线程刚刚将业务受理完成，准备解锁，然后又坐下继续办理业务，所以此时的current还是第一个线程，当前getExclusiveOwnerThread()方法获取到的是也是正在受理的线程，即第一个线程，所以进入else if 判断框，此时nextc = 1+1，设置状态为2，返回true，外层方法结束，此种情况是可重入锁会进入这个判断代码。
```

如果 return false ，则继续推进条件，走下一个方法addWaiter；如果return true，外层的acquire(int aeg)方法就直接结束。

**addWaiter(Node.EXCLUSIVE)方法**

![addWaiter()方法](images/addWaiter()方法.jpg)

enq(node)方法

![enq()方法](images/enq()方法.jpg)

代码解读

```
enq(node)方法是一个自旋锁方法，第二个线程进入tryAcquire() -> addWaiter() -> enq();第一次进来tail结点为null，需要初始化，创建一个新节点，并且将head指向它，然后将head指向tail，其实创建的新节点就是一个哨兵节点（如下图一）。继续自旋，此时的tail结点已经初始化完成，不在为null，所以走else分支，真是将此时的第二个线程结点加入队列（如下图二）。
```

![图一](images/enq()创建哨兵节点.jpg)

![图二](images/enq()创建队列节点.jpg)

双向链表中，第一个节点为虚节点(也叫哨兵节点)，其实并不存储任何信息，只是占位。真正的第一个有数据的结点，是从第二个结点开始的 。

假如下一个Thread线程进来，将会进行：

- prev
- compareAndSetTail
- next

#### acquireQueued(addWaiter(Node.EXCLUSIVE),arg)

acquireQueued（让线程入队，然后等待LockSupport进行park阻塞操作，执行到这一步才算是真正的入队成功了）

![acquireQueued()方法](images/acquireQueued()方法.jpg)

如果抢占失败，就进入到蓝色框框

shouldParkAfterFailedAcquire 和 parkAndCheckInterrupt方法中 

![shouldParkAfterFailedAcquire](images/shouldParkAfterFailedAcquire.jpg)

shouldParkAfterFailedAcquire 方法

![shouldParkAfterFailedAcquire](images/shouldParkAfterFailedAcquire (1).jpg)

![shouldParkAfterFailedAcquire](images/shouldParkAfterFailedAcquire (2).jpg)

如果前驱结点的waitStatus是SIGNAL状态，即shouldParkAfterFailedAcquire方法会返回true程序会继续向下执行 parkAndCheckInterrupt 方法，用于将当前线程挂起

parkAndCheckInterrupt方法

![parkAndCheckInterrupt](images/parkAndCheckInterrupt.jpg)

#### 方法unlock()

sync.release(1)  -> tryRelease(arg) -> unparkSuccessor

杀回马枪

![1616662373](images/1616662373.jpg)

