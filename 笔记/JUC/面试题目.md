https://blog.csdn.net/wxy1234556/article/details/86033765

#### Synchronized的原理是什么？

```
Synchronized是由 JVM 实现的一种实现互斥同步的一种方式，如果你查看被Synchronized 修饰过的程序块编译后会发现，被Synchronized 修饰过的程序块，在编译前后被编译器生成了monitorenter 和 monitorexit 两个字节码指令

这两个指令是什么意思呢？
在虚拟机执行到 monitorenter 指令时，首先要尝试获取对象的锁：

如果这个对象没有锁定，或者当前线程已经拥有了当前这个对象的锁，把锁的计数器+1；当执行 monitorexit 指令时将锁计数器-1；当计数器为0时，锁就被释放了。

如果获取对象失败了，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。

Java中 Synchronized 通过在对象头设置标记，达到了获取锁和释放锁的目的。
```

#### 你刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？

```
“锁”的本质其实是 monitorenter 和 monitorexit 字节码指令的一个Reference类型的参数，即要锁定和解锁的对象。使用 Synchronized 可以修饰不同的对象，因此，对应的对象锁可以这么确定。

1.如果 Synchronized 明确指定了锁的对象，比如 Synchronized(变量名)，Synchronized(this)等，说明加解锁对象为该对象。

2.如果没有明确指定：
	若 Synchronized 修饰的方法为非静态方法，表示此方法对应的对象为锁对象；
	若 Synchronized 修饰的方法为静态方法，则表示此方法对应的类对象为锁对象。

注意，当一个对象被锁住时，对象里面所有用 Synchronized 修饰的方法都将产生堵塞，而对象里非 Synchronized 修饰的方法可正常被调用，不受锁影响。
```

#### 什么是可重入性，为什么说 Synchronized 是可重入锁？

```
可重入性是锁的一个基本要求，是为了解决自己锁死自己的情况。

对Synchronized 来说，可重入性是显而易见的，刚才提到，在执行monitorenter 指令时，如果这个对象没有锁定或者当前线程已经拥有了这个对象的锁（而不是已拥有了锁则不能继续获取），就把锁的计数器 +1，其实本质上就通过这种方式实现了可重入性。
```

#### 为什么说 Synchronized 是非公平锁？

```
非公平主要表现在获取锁的行为上，并非是按照申请锁的时间前后给等待线程分配锁的，每当锁被释放后任何一个线程都有机会竞争到锁，这样做的目的是为了提高执行性能，缺点是可能会产生线程饥饿现象。
```

#### 为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？

```
Synchronized 显然是一个悲观锁，因为它的并发策略时悲观的：

不管是否会产生竞争，任何的数据操作都必须要加锁，用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等操作。

随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略。先进行操作，如果没有其他线程征用数据，那操作就成功了；

如果共享数据有征用，产生了冲突，那就再进行其他的补偿措施。这种乐观的并发策略的许多实现不需要线程挂起，所以被称为非阻塞同步。

乐观锁的核心算法时CAS(Compareand And Swap，比较并交换),它涉及到三个操作数：内存值、预期值、新值。当前仅当预期值和内存值相等时才将内存值修改为新值。

这样处理的逻辑是，首先检查某块内存的值是否跟我们之前读取时的一样，如果不一样则表示期间此内存值已经被别的线程更改过，舍弃本次操作，否则说明期间没有其他线程对此内存值操作，可以把新值设置给此块内存。

CAS具有原子性，它的原子性由CPU 硬件指令实现保证，即使用JNI 调用 Native 方法调用由 C++ 编写的硬件级别指令，JDK 中提供了 Unsafe 类执行这些操作。
```

#### 乐观锁一定就是好的吗？

```
乐观锁避免了悲观锁独占对象的现象，同时也提高了并发性能，但它也有缺点：
	乐观锁只能保证一个共享变量的原子操作。如果多一个或几个变量，乐观锁将变得力不从心，但互斥锁能轻易解决，不管对象数量多少及对象颗粒度大小。
	
	长时间自旋可能导致开销大。例如 CAS 长时间不成功而一直自旋，会给 CPU 带来很大的开销。
	
	ABA 问题。CAS 的核心思想是通过比对内存值与预期值是否一样而判断内存值是否被改过，但这个判断逻辑不严谨，假如内存值原来是 A，
	后来被一条线程改为 B，最后又被改成了 A，则 CAS 认为此内存值并没有发生改变，但实际上是有被其他线程改过的，
	这种情况对依赖过程值的情景的运算结果影响很大。解决的思路是引入版本号，每次变量更新都把版本号加一。
```



#### 跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？

```
其实，锁的实现原理基本是为了达到一个目的：让所有的线程都能看到某种标记。

Synchronized 通过在对象头中设置标记实现了这一目的，是一种 JVM 原生的锁实现方式，而 ReentrantLock 以及所有的基于Lock 接口的实现类，都是通过一个 volitile 修饰的 int 型变量，并保证每个线程都能拥有对该int 的可见性和原子修改，其本质是基于所谓的 AQS 框架。
```

#### 那么请谈谈 AQS 框架是怎么回事儿？

```
AQS（AbstractQueuedSynchronizer 类）是一个用来构建锁和同步器的框架，各种 Lock 包中的锁（常用的有 ReentrantLock、ReadWriteLock），以及其他如 Semaphore、CountDownLatch，甚至是早期的 FutureTask 等，都是基于 AQS 来构建。

1.AQS 在内部定义了一个 volatile int state 变量，表示同步状态：当线程调用 lock 方法时 ，如果 state=0，说明没有任何线程占有
共享资源的锁，可以获得锁并将 state=1；如果 state=1，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待。

2.AQS 通过 Node 内部类构成的一个双向链表结构的同步队列，来完成线程获取锁的排队工作，当有线程获取锁失败后，就被添加到队列末尾。

Node 类是对要访问同步代码的线程的封装，包含了线程本身及其状态叫 waitStatus（有五种不同 取值，分别表示是否被阻塞，是否等待唤
醒，是否已经被取消等），每个 Node 结点关联其 prev 结点和 next 结点，方便线程释放锁后快速唤醒下一个在等待的线程，
是一个 FIFO 的过程。

Node 类有两个常量，SHARED 和 EXCLUSIVE，分别代表共享模式和独占模式。所谓共享模式是一个锁允许多条线程同时操作
（信号量 Semaphore 就是基于 AQS 的共享模式实现的），独占模式是同一个时间段只能有一个线程对共享资源进行操作，
多余的请求线程需要排队等待（如 ReentranLock）。

3.AQS 通过内部类 ConditionObject 构建等待队列（可有多个），当 Condition 调用 wait() 方法后，线程将会加入等待队列中，
而当 Condition 调用 signal() 方法后，线程将从等待队列转移动同步队列中进行锁竞争。

4.AQS 和 Condition 各自维护了不同的队列，在使用 Lock 和 Condition 的时候，其实就是两个队列的互相移动。
```





