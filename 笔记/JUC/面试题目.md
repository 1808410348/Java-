#### Synchronized的原理是什么？

```
Synchronized是由 JVM 实现的一种实现互斥同步的一种方式，如果你查看被Synchronized 修饰过的程序块编译后会发现，被Synchronized 修饰过的程序块，在编译前后被编译器生成了monitorenter 和 monitorexit 两个字节码指令

这两个指令是什么意思呢？
在虚拟机执行到 monitorenter 指令时，首先要尝试获取对象的锁：

如果这个对象没有锁定，或者当前线程已经拥有了当前这个对象的锁，把锁的计数器+1；当执行 monitorexit 指令时将锁计数器-1；当计数器为0时，锁就被释放了。

如果获取对象失败了，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。

Java中 Synchronized 通过在对象头设置标记，达到了获取锁和释放锁的目的。
```

#### 你刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？

```
“锁”的本质其实是 monitorenter 和 monitorexit 字节码指令的一个Reference类型的参数，即要锁定和解锁的对象。使用 Synchronized 可以修饰不同的对象，因此，对应的对象锁可以这么确定。

1.如果 Synchronized 明确指定了锁的对象，比如 Synchronized(变量名)，Synchronized(this)等，说明加解锁对象为该对象。

2.如果没有明确指定：
	若 Synchronized 修饰的方法为非静态方法，表示此方法对应的对象为锁对象；
	若 Synchronized 修饰的方法为静态方法，则表示此方法对应的类对象为锁对象。

注意，当一个对象被锁住时，对象里面所有用 Synchronized 修饰的方法都将产生堵塞，而对象里非 Synchronized 修饰的方法可正常被调用，不受锁影响。
```

#### 什么是可重入性，为什么说 Synchronized 是可重入锁？

```
可重入性是锁的一个基本要求，是为了解决自己锁死自己的情况。

对Synchronized 来说，可重入性是显而易见的，刚才提到，在执行monitorenter 指令时，如果这个对象没有锁定或者当前线程已经拥有了这个对象的锁（而不是已拥有了锁则不能继续获取），就把锁的计数器 +1，其实本质上就通过这种方式实现了可重入性。
```

#### JVM 对 Java 的原生锁做了哪些优化？

```

```











