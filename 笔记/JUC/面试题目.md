#### Synchronized的原理是什么？

```
Synchronized是由 JVM 实现的一种实现互斥同步的一种方式，如果你查看被Synchronized 修饰过的程序块编译后会发现，被Synchronized 修饰过的程序块，在编译前后被编译器生成了monitorenter 和 monitorexit 两个字节码指令

这两个指令是什么意思呢？
在虚拟机执行到 monitorenter 指令时，首先要尝试获取对象的锁：

如果这个对象没有锁定，或者当前线程已经拥有了当前这个对象的锁，把锁的计数器+1；当执行 monitorexit 指令时将锁计数器-1；当计数器为0时，锁就被释放了。

如果获取对象失败了，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。

Java中 Synchronized 通过在对象头设置标记，达到了获取锁和释放锁的目的。
```

#### 你刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？

```
“锁”的本质其实是 monitorenter 和 monitorexit 字节码指令的一个Reference类型的参数，即要锁定和解锁的对象。使用 Synchronized 可以修饰不同的对象，因此，对应的对象锁可以这么确定。

1.如果 Synchronized 明确指定了锁的对象，比如 Synchronized(变量名)，Synchronized(this)等，说明加解锁对象为该对象。

2.如果没有明确指定：
	若 Synchronized 修饰的方法为非静态方法，表示此方法对应的对象为锁对象；
	若 Synchronized 修饰的方法为静态方法，则表示此方法对应的类对象为锁对象。

注意，当一个对象被锁住时，对象里面所有用 Synchronized 修饰的方法都将产生堵塞，而对象里非 Synchronized 修饰的方法可正常被调用，不受锁影响。
```

#### 什么是可重入性，为什么说 Synchronized 是可重入锁？

```
可重入性是锁的一个基本要求，是为了解决自己锁死自己的情况。

对Synchronized 来说，可重入性是显而易见的，刚才提到，在执行monitorenter 指令时，如果这个对象没有锁定或者当前线程已经拥有了这个对象的锁（而不是已拥有了锁则不能继续获取），就把锁的计数器 +1，其实本质上就通过这种方式实现了可重入性。
```

#### 为什么说 Synchronized 是非公平锁？

```
非公平主要表现在获取锁的行为上，并非是按照申请锁的时间前后给等待线程分配锁的，每当锁被释放后任何一个线程都有机会竞争到锁，这样做的目的是为了提高执行性能，缺点是可能会产生线程饥饿现象。
```

#### 为什么说 Synchronized 是一个悲观锁？乐观锁的实现原理又是什么？什么是 CAS，它有什么特性？

```
Synchronized 显然是一个悲观锁，因为它的并发策略时悲观的：

不管是否会产生竞争，任何的数据操作都必须要加锁，用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等操作。

随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略。先进行操作，如果没有其他线程征用数据，那操作就成功了；

如果共享数据有征用，产生了冲突，那就再进行其他的补偿措施。这种乐观的并发策略的许多实现不需要线程挂起，所以被称为非阻塞同步。

乐观锁的核心算法时CAS(Compareand And Swap，比较并交换),它涉及到三个操作数：内存值、预期值、新值。当前仅当预期值和内存值相等时才将内存值修改为新值。

这样处理的逻辑是，首先检查某块内存的值是否跟我们之前读取时的一样，如果不一样则表示期间此内存值已经被别的线程更改过，舍弃本次操作，否则说明期间没有其他线程对此内存值操作，可以把新值设置给此块内存。

CAS具有原子性，它的原子性由CPU 硬件指令实现保证，即使用JNI 调用 Native 方法调用由 C++ 编写的硬件级别指令，JDK 中提供了 Unsafe 类执行这些操作。
```

#### 乐观锁一定就是好的吗？

```
乐观锁避免了悲观锁独占对象的现象，同时也提高了并发性能，但它也有缺点：
	乐观锁只能保证一个共享变量的原子操作。如果多一个或几个变量，乐观锁将变得力不从心，但互斥锁能轻易解决，不管对象数量多少及对象颗粒度大小。
	
	长时间自旋可能导致开销大。例如 CAS 长时间不成功而一直自旋，会给 CPU 带来很大的开销。
	
	ABA 问题。CAS 的核心思想是通过比对内存值与预期值是否一样而判断内存值是否被改过，但这个判断逻辑不严谨，假如内存值原来是 A，
	后来被一条线程改为 B，最后又被改成了 A，则 CAS 认为此内存值并没有发生改变，但实际上是有被其他线程改过的，
	这种情况对依赖过程值的情景的运算结果影响很大。解决的思路是引入版本号，每次变量更新都把版本号加一。
```





