LockSupport 代码无锁块要求

```java
// a  -----come in
// b  -----b 发出唤醒通知了
// a  -----被唤醒
public static void lockSupportParkUnpark(){
        Thread a = new Thread(() -> {
//            try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); }
            System.out.println(Thread.currentThread().getName() + "\t" + "-----come in");
            LockSupport.park(); // 被阻塞，等待通知，等待放行
            System.out.println(Thread.currentThread().getName() + "\t" + "-----被唤醒");
        }, "a");
        a.start();

        try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }

        Thread b = new Thread(() -> {
            LockSupport.unpark(a); // 放行
            System.out.println(Thread.currentThread().getName() + "\t" + "-----b 发出唤醒通知了");
        }, "b");
        b.start();
    }
```

不仅如此，LockSupport还支持之前错误的先唤醒后等待

```java
// b  -----b 发出唤醒通知了
// a  -----come in
// a  -----被唤醒
public static void lockSupportParkUnpark(){
    Thread a = new Thread(() -> {
        try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); }
        System.out.println(Thread.currentThread().getName() + "\t" + "-----come in");
        LockSupport.park(); // 被阻塞，等待通知，等待放行
        System.out.println(Thread.currentThread().getName() + "\t" + "-----被唤醒");
    }, "a");
    a.start();

    try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }

    Thread b = new Thread(() -> {
        LockSupport.unpark(a); // 放行
        System.out.println(Thread.currentThread().getName() + "\t" + "-----b 发出唤醒通知了");
    }, "b");
    b.start();
}
```

![1616227053](1\1616227053.jpg)

### 重要说明

**LockSupport是用来创建锁和其他同步类的基本线程阻塞原语**。

LockSupport是一个线程阻塞类工具类，所有的方法都是静态方法，可以让线程在任意位置阻塞，阻塞之后也有对应的唤醒方法。归根结底，LockSupport调用的unsafe中的native代码。

**LockSupport提供park()和unpark()方法实现阻塞线程和解除阻塞线程的过程。**

LockSupport和每个使用它的线程都有一个许可（permit）关联。permit相当于1,0的开关，默认是0，调用一次unpark()就加1变成1，调用一次park()会消费permit，也就是将1变成0，同时park立即返回。

如果再次调用park会变成阻塞（因为permit为零了会阻塞在这里，一直到permit变为1），这时调用unpark会把permit置为1。

每个线程都有一个相关的permit，permit最多只有一个，重复调用unpark也不会积累凭证。

**形象的理解**
线程阻塞需要消耗凭证(permit)，这个凭证最多只有1个。 
**当调用park方法时 **
如果有凭证，则会直接消耗掉这个凭证然后正常退出；
如果无凭证，就必须阻塞等待凭证可用；
而unpark则相反，它会增加一个凭证，但是凭证最多只能有1个，累加无效。





