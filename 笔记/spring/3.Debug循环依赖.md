实例化/初始化

实例化：内存中申请一块内存空间，好似租赁一房子，自己的家具东西都还没有搬家进去。

初始化属性填充：完成属性的各种赋值，好似装修、家电家具进场。

#### 3个Map和四大方法，总体相关对象

![三个Map和四大方法](images/三个Map和四大方法.jpg)

第一层 singletonObjects 存放的是已经初始化好了的Bean，

第二层 earlySingletonObjects 存放的是实例化了，但未初始化的Bean，

第三层singletonFactories存放的是FactoryBean。假如A类实现了FactoryBean，那么依赖注入的时候不是A类，而是A类产生的Bean。

![三个Map](images/三个Map.jpg)

#### A/B两对象在三级缓存中的迁移说明

1. A创建过程中需要B，于是A将自己放到三级缓存里面，去实例化B
2. B实例化的时候发现需要A，于是B先去一级缓存查找，没有，再去二级缓存查，还是没有，在查三级缓存，找到了A然后把三级缓存里面的这个A放到二级缓存里面，并删除三级缓存里面的A
3. B顺利初始化完成，将自己放到一级缓存里面（此时B里面的A是创建中状态），然后回来接着创建A，此时B已经创建结束，直接从一级缓存里面拿B，然后完成创建，并将A自己放到一级缓存里面。

![](images/ObjectFactory.jpg)



全部Debug断点

![spring循环依赖Debug断点](images/spring循环依赖Debug断点.jpg)



创建循环依赖时，程序在加载xml文件时，我们会调用this.refresh();方法

--> 在this.refresh();方法里面调用this.finishBeanFactoryInitialization(beanFactory);方法

--> beanFactory.preInstantiateSingletons();

--> this.getBean(beanName);

--> doGetBean(String name, Class<T> requiredType, final Object[] args, boolean typeCheckOnly)

--> 然后初始化创建bean A，控制台会打印出创建A成功的输出（前提是我们在A方法的无偿构造器中有输出语句）

--> addSingletonFactory(String beanName, ObjectFactory<?> singletonFactory);调用此方法将bean A放入到三级缓存中

```java
protected void addSingletonFactory(String beanName, ObjectFactory<?> singletonFactory) {
    Assert.notNull(singletonFactory, "Singleton factory must not be null");
    synchronized(this.singletonObjects) {
        if (!this.singletonObjects.containsKey(beanName)) {
            this.singletonFactories.put(beanName, singletonFactory);
            this.earlySingletonObjects.remove(beanName);
            this.registeredSingletons.add(beanName);
        }
    }
}
```

--> populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw); bean A初步完成

--> 相同的步骤，程序在回来创建bean B，并把bean B放到三级缓存中

--> bean B 放入三级缓存之后，bean A又回来调用getSingleton(String beanName, boolean allowEarlyReference)；方法，将自己放入到二级缓存，并将自己从三级缓存中移除

--> 然后又回来创建bean B，调用addSingleton(String beanName, Object singletonObject) ;方法，直接将自己放到一级缓存里面，同时从三级缓存中移除，不用放入到二级缓存，此时的bean B已经算创建完成。

--> 现在又回过头来创建bean A，调用addSingleton(String beanName, Object singletonObject) ;方法，将bean A从二级缓存移动到一级缓存中，同时从二级缓存中移除。







---------------------

