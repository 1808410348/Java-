##### 面试题

解释Spring中的三级缓存?

三级缓存分别是什么？三个Map有什么异同？

什么是循环依赖？一般我们说spring容器是什么？

如何检测是否存在循环依赖？实际开发中见过循坏依赖的异常吗？

多例情况下，循环依赖问题为什么无法解决？

#### 什么是循坏依赖

多个bean之间的互相依赖，形成一个闭环；比如A依赖于B，B依赖于C，C依赖于A

```java
public class T1 {

    class A{
        B b;
    }
    class B{
        C c;
    }
    class C{
        A a;
    }
}
 
比如：A依赖于B、B依赖于C、C依赖于A
```

通常来说，如果问Spring容器内部如何解决循环依赖，**一定是指默认的单例Bean中**，属性互相引用的场景

![循环依赖](images/循环依赖.jpg)

#### 两种注入方式对循环依赖的影响

两种循环方式指的是构造方法注入和get set方法注入。

循环依赖官网说明(https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-dependency-resolution)

![循环依赖官网解释](images/循环依赖官网解释.jpg)



**结论**
我们AB循环依赖问题只要A的注入方式是setter且singleton，就不会有循环依赖问题。

#### spring容器循环依赖报错演示BeanCurrentlyCreationException

**构造器方式注入依赖**

ServiceA代码

```java
package com.romanticlei.study.interview.spring.circulardepend.constructorinjection;

import org.springframework.stereotype.Component;

@Component
public class ServiceA {

    private ServiceB serviceB;

    public ServiceA(ServiceB serviceB) {
        this.serviceB = serviceB;
    }
}
```

ServiceB代码

```java
package com.romanticlei.study.interview.spring.circulardepend.constructorinjection;

import org.springframework.stereotype.Component;

@Component
public class ServiceA {

    private ServiceB serviceB;

    public ServiceA(ServiceB serviceB) {
        this.serviceB = serviceB;
    }
}
```

ClientConstructor代码

```java
package com.romanticlei.study.interview.spring.circulardepend.constructorinjection;

public class ClientConstructor {

    public static void main(String[] args) {
  // 无限套娃
        new ServiceA(new ServiceB(new ServiceA(。。。)));
    }
}
```

通过代码可以看出构造器循环依赖是无法解决，你想让构造器注入支持循环依赖，是不存在的只会无限套娃。

**以set方式注入依赖**

ServiceAA

```java
package com.romanticlei.study.interview.spring.circulardepend.setinjection;

import org.springframework.stereotype.Component;

@Component
public class ServiceAA {
    private ServiceBB serviceBB;

    public void setServiceBB(ServiceBB serviceBB) {
        this.serviceBB = serviceBB;
        System.out.println("A 里面设置了 B");
    }
}
```

ServiceBB

```java
package com.romanticlei.study.interview.spring.circulardepend.setinjection;

import org.springframework.stereotype.Component;

@Component
public class ServiceBB {
    private ServiceAA serviceAA;

    public void setServiceAA(ServiceAA serviceAA) {
        this.serviceAA = serviceAA;
        System.out.println("B 里面设置了 A");
    }
}
```

ClientSet

```java
package com.romanticlei.study.interview.spring.circulardepend.setinjection;

public class clientSet {
    public static void main(String[] args) {
        // 创建ServiceAA
        ServiceAA a = new ServiceAA();
        // 创建ServiceBB
        ServiceBB b = new ServiceBB();

        // 将serviceA注入到ServiceB中
        b.setServiceAA(a);
        // 将ServiceB注入到ServiceA中
        a.setServiceBB(b);
    }
}
```

#### 重要code案例演示

code-java 基础

```java
package com.romanticlei.study.interview.spring.circulardepend.javaSE;

public class A {

    private B b;

    public B getB() {
        return b;
    }

    public void setB(B b) {
        this.b = b;
    }

    public A() {
        System.out.println("创建A成功");
    }
}
```

```java
package com.romanticlei.study.interview.spring.circulardepend.javaSE;

public class B {

    private A a;

    public A getA() {
        return a;
    }

    public void setA(A a) {
        this.a = a;
    }

    public B() {
        System.out.println("创建B成功");
    }
}
```

```java
package com.romanticlei.study.interview.spring.circulardepend.javaSE;

public class ClientCode {

    public static void main(String[] args) {
        A a = new A();
        B b = new B();

        a.setB(b);
        b.setA(a);
    }
}
```













