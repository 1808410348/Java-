### redis 缓存淘汰策略

#### 往 redis 里写的数据是怎么没了的？

redis 过期键的删除策略，如果一个键是过期，那它到期之后是不是马上就从内存中删除呢？如果回答是，基本本次面试基本宣告失败。如果不是，那过期后到底什么时候被删除呢？

三种不同的删除策略

1. 立即删除
   Redis不可能时时刻刻遍历所有被设置上了生存时间的key，来检测数据是否已经到达过期时间，然后对它进行删除。
   立马删除能保证内存中数据的最大新鲜度，因为它保证过期键值会在过期后马上被删除，其所占用的内存也会随之被释放，但是立即删除对CPU是最不友好的，因为删除操作会占用CPU的时间，如果刚好碰上了CPU很忙的时候，比如正在做交集或排序等计算的时候，就会给CPU造成额外的压力，让CPU心累，时时需要删除。
   **这会产生大量的性能消耗，同时也会影响数据的读取操作。**
   总结：对CPU不友好，用处理器性能换取存储空间（时间换空间）
   
2. 惰性删除
   数据到达过期时间不删除，不做处理，等下次访问该数据的时候，**如果未过期**，返回数据；**如果过期**，删除，返回不存在
   **惰性删除策略的缺点是，它对内存是最不有好的。**
   如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。
   在使用惰性删除策略时，如果数据库中有非常多的过期键，**而这些过期键又恰好没有被访问的话，那么它们也许永远都不会被删除**（除非用户手动执行FLUSHDB），我们甚至可以将这种情况看作是一种内存泄露，无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放他们，这对于运行状态非常依赖于内存的Redis服务器来说，这不是一个好消息。
   总结：对内存不友好，用存储空间换取处理器性能（空间换时间）
   
3. 定期删除
   对于上面过于极端的情况，我们有了定期删除策略，它是前两种策略的一种折中：定期删除策略**每隔一段时间执行一次过期删除键操作**，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。

   周期性轮询 redis 库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度
   特点1：CPU性能占用设置峰值，检测频度可自定义设置

   特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理

   总结：周期性抽查存储空间

   举例：

   redis 每隔100ms(这个时间可以自己设置) 检查，是否有过期的key，有过期key则删除。注意：redis不是每隔100ms将所有key检查一次，而是随机抽取进行检查（如果每隔100ms，全部进行key检查，redis直接进ICU）。因此，如果采用定期删除策略，会导致很多key到时间没有删除。

   定时删除策略的难点是确定删除操作执行的时长和频率：如果删除操作执行得太频繁，或者执行时间太长，定时删除策略就会退化成立即删除策略，以至于将CPU时间过多地消耗在删除过期键上面。如果删除操作执行得太少，或者执行的时间太短定时删除策略又会和惰性删除策略一样，出现浪费内存的情况。因此，如果采用定时删除策略的话，服务器必须根据情况，**合理地设置删除操作的执行时长和执行频率**。

   总结：定期抽样key，判断是否过期，这种方式存在漏网之鱼

定期删除时，从来没有被抽查到；惰性删除，也从来没有被选中使用过，上述步骤都会产生大量过期的key堆积在内存中，导致 redis 内存空间紧张或者消耗殆尽。这时候就需要一个更好的兜底方案。

这时候内存淘汰策略登场（redis 6.0.8版本）

- noeviction：不会驱逐任何key
- allkeys- lru：对所有key使用LRU算法进行删除
- volatile- lru：对所有设置了过期时间的key使用LRU算法进行删除
- allkeys- random：对所有key随机删除
- volatile- random：对所有设置了过期时间的key随机删除
- volatile- ttl：删除马上过期的key
- allkeys- lfu：对所有key使用LFU算法进行删除
- volatile- lfu：对所有设置了过期时间的key使用LFU算法进行删除

2个维度：过期键中筛选；所有键中筛选

4个方面：LRU，LFU，RANDOM，TTL

8个选项



如何配置、修改

```
通过命令修改
config set maxmemory- policy allkeys- lru
```

通过配置文件修改

```
maxmemory- policy allkeys- lru
```

